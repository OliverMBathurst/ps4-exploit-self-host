import React, { createContext, useContext, useEffect, useMemo, useRef, useState } from 'react'
import { ServiceContext } from '.'
import { FirmwareVersion } from '../enums'
import { getLocalStorageSize } from '../helpers'
import { IDirectory } from '../interfaces'
import { ModalContext } from './modalContext'

interface ICacheContextComponentProps {
    children: React.ReactNode
}

interface ICacheContext {
    firmwareVersion: FirmwareVersion,
    isCacheModeOn: boolean
    directoryMappingsCached: boolean
    payloadsCached: boolean
    objectStoresKeyCount: number
    localStorageSize: number
    directoryMap: Map<number, IDirectory> | null
    payloadCacheKeysSet: Set<string> | null
    onLocalStorageSizeChanged: () => void
    setIsCacheModeOn: (on: boolean) => void
    togglePayloadCacheInclusion: (cacheIdentifier: string, buffer: Uint8Array) => Promise<void>
    clearPayloadCache: () => Promise<void>
    clearObjectStores: () => Promise<void>
    cacheDirectoryPayloads: (directory: IDirectory) => Promise<void>
    cacheDirectoryMappings: () => Promise<void>
    clearCachedDirectoryMappings: () => Promise<void>
    setFirmwareVersion: (firmwareVersion: FirmwareVersion) => void
}

export const CacheContext = createContext<ICacheContext>({
    firmwareVersion: FirmwareVersion.Undefined,
    isCacheModeOn: false,
    payloadCacheKeysSet: null,
    directoryMappingsCached: false,
    payloadsCached: false,
    objectStoresKeyCount: 0,
    localStorageSize: 0,
    directoryMap: null,
    onLocalStorageSizeChanged: () => Function.prototype,
    setIsCacheModeOn: () => Function.prototype,
    togglePayloadCacheInclusion: (_identifier: string, _buffer: Uint8Array) => Promise.prototype,
    clearPayloadCache: () => Promise.prototype,
    clearObjectStores: () => Promise.prototype,
    cacheDirectoryPayloads: (_: IDirectory) => Promise.prototype,
    cacheDirectoryMappings: () => Promise.prototype,
    clearCachedDirectoryMappings: () => Promise.prototype,
    setFirmwareVersion: (_: FirmwareVersion) => Function.prototype
})

const CacheContextComponent = (props: ICacheContextComponentProps) => {
    const { children } = props

    const {
        payloadCachingService,
        manifestService,
        binService,
        databaseService
    } = useContext(ServiceContext)

    const { addModal } = useContext(ModalContext)

    const [isCacheModeOn, setIsCacheModeOn] = useState(false)
    const [payloadCacheKeysSet, setPayloadCacheKeysSet] = useState<Set<string> | null>(null)
    const [directoryMappingsCached, setDirectoryMappingsCached] = useState(false)
    const [directoryMap, setDirectoryMap] = useState<Map<number, IDirectory> | null>(null)
    const [firmwareVersion, setFirmwareVersion] = useState<FirmwareVersion>(FirmwareVersion.Undefined)
    const [objectStoresKeyCount, setObjectStoresKeyCount] = useState(0)
    const [localStorageSize, setLocalStorageSize] = useState(getLocalStorageSize())

    const firmwareVersionRef = useRef<FirmwareVersion>()

    useEffect(() => {
        let mounted = true

        async function loadData() {
            const { data: hasCachedDirectoryMappings } = await manifestService.hasCacheKeys()
            const fetchedPayloadCacheKeys = await payloadCachingService.getCacheKeys()
            const cacheKeysSet = fetchedPayloadCacheKeys.data
                ? new Set<string>(fetchedPayloadCacheKeys.data.map(key => key.toString()))
                : null

            if (mounted) {
                setDirectoryMappingsCached(hasCachedDirectoryMappings)
                setPayloadCacheKeysSet(cacheKeysSet)
            }
        }

        loadData()

        return () => {
            mounted = false
        }
    }, [payloadCachingService, manifestService])

    useEffect(() => {
        let mounted = true

        async function loadData() {
            let dirMap = await manifestService.getDirectoryMap(firmwareVersion)

            if (mounted) {
                setDirectoryMap(dirMap)
            }

            firmwareVersionRef.current = firmwareVersion
        }

        if (firmwareVersion !== firmwareVersionRef.current) {
            loadData()
        }

        return () => {
            mounted = false
        }
    }, [firmwareVersion, directoryMappingsCached, manifestService])

    useEffect(() => {
        let mounted = true

        async function loadData() {
            const { data: storesCount } = await databaseService.getObjectStoreKeyCount()
            if (mounted) {
                setObjectStoresKeyCount(storesCount)
            }
        }

        loadData()

        return () => {
            mounted = false
        }
    }, [payloadCacheKeysSet, directoryMappingsCached, databaseService])

    const payloadsCached: boolean = useMemo(() => {
        if (!payloadCacheKeysSet) {
            return false
        }

        return payloadCacheKeysSet.size > 0
    }, [payloadCacheKeysSet])

    const cacheDirectoryMappings = async (): Promise<void> => {
        await manifestService.cacheAllDirectoryMappings()
        setDirectoryMappingsCached(true)
    }

    const clearCachedDirectoryMappings = async (): Promise<void> => {
        await manifestService.clearAssociatedObjectStore()
        setDirectoryMappingsCached(false)
    }

    const togglePayloadCacheInclusion = async (cacheIdentifier: string, buffer: Uint8Array): Promise<void> => {
        const copyCacheMap = payloadCacheKeysSet
            ? new Set<string>(payloadCacheKeysSet)
            : new Set<string>()

        const result = await payloadCachingService.togglePayloadCacheInclusion(cacheIdentifier, buffer)

        if (result) {
            copyCacheMap.add(cacheIdentifier)
        } else {
            copyCacheMap.delete(cacheIdentifier)
        }

        setPayloadCacheKeysSet(copyCacheMap)
    }

    const clearPayloadCache = async (): Promise<void> => {
        await payloadCachingService.clearAssociatedObjectStore()
        setPayloadCacheKeysSet(null)
    }

    const clearObjectStores = async (): Promise<void> => {
        const result = await databaseService.clearObjectStores()

        if (result.success) {
            setDirectoryMappingsCached(false)
            setPayloadCacheKeysSet(null)
        } else {
            addModal({
                title: "Object store clearance error.",
                message: result.message
            })
        }
    }

    const cacheDirectoryPayloads = async (directory: IDirectory): Promise<void> => {
        const cachedPayloads = payloadCacheKeysSet
            ? new Set<string>(payloadCacheKeysSet)
            : new Set<string>()

        const nonCached = directory.payloads.filter(p => !cachedPayloads.has(p.path))

        for (var { path: payloadPath } of nonCached) {
            const buffer = await binService.getBINFile(payloadPath)
            if (!buffer) {
                continue
            }

            await payloadCachingService.addToObjectStore(payloadPath, buffer)
            cachedPayloads.add(payloadPath)
        }

        setPayloadCacheKeysSet(cachedPayloads)
    }

    return (
        <CacheContext.Provider value={{
            firmwareVersion: firmwareVersion,
            isCacheModeOn: isCacheModeOn,
            payloadCacheKeysSet: payloadCacheKeysSet,
            setIsCacheModeOn: setIsCacheModeOn,
            togglePayloadCacheInclusion: togglePayloadCacheInclusion,
            onLocalStorageSizeChanged: () => setLocalStorageSize(getLocalStorageSize),
            clearPayloadCache: clearPayloadCache,
            clearObjectStores: clearObjectStores,
            objectStoresKeyCount: objectStoresKeyCount,
            localStorageSize: localStorageSize,
            directoryMap: directoryMap,
            directoryMappingsCached: directoryMappingsCached,
            payloadsCached: payloadsCached,
            cacheDirectoryPayloads: cacheDirectoryPayloads,
            cacheDirectoryMappings: cacheDirectoryMappings,
            clearCachedDirectoryMappings: clearCachedDirectoryMappings,
            setFirmwareVersion: setFirmwareVersion
        }}>
            {children}
        </CacheContext.Provider>)
}

export default CacheContextComponent