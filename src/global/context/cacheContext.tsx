import React, { createContext, useContext, useEffect, useMemo, useState } from 'react'
import { FirmwareVersionContext } from '.'
import { FirmwareVersion } from '../enums'
import { getLocalStorageSize } from '../helpers'
import { IDirectory, IPayload } from '../interfaces'
import { ManifestService, PayloadCachingService } from '../services'

interface ICacheContextComponentProps {
    children: React.ReactNode
}

interface ICacheContext {
    isCacheModeOn: boolean
    localStorageSize: number
    payloadCacheMap: Map<string, ArrayBuffer> | null
    setIsCacheModeOn: (on: boolean) => void
    togglePayloadCacheInclusion: (payload: IPayload, buffer: ArrayBuffer) => void
    clearPayloadCache: () => void
    clearLocalStorage: () => void
    directoryMap: Map<number, IDirectory> | null
    hasCachedManifests: boolean
    onCacheManifests: () => void
    onClearCachedManifests: () => void
}

export const CacheContext = createContext<ICacheContext>({
    isCacheModeOn: false,
    payloadCacheMap: null,
    localStorageSize: 0,
    setIsCacheModeOn: () => Function.prototype,
    togglePayloadCacheInclusion: (_: IPayload, __: ArrayBuffer) => Function.prototype,
    clearPayloadCache: () => Function.prototype,
    clearLocalStorage: () => Function.prototype,
    hasCachedManifests: false,
    directoryMap: null,
    onCacheManifests: () => Function.prototype,
    onClearCachedManifests: () => Function.prototype
})

const payloadCachingService = new PayloadCachingService(), manifestService = new ManifestService()

const CacheContextComponent = (props: ICacheContextComponentProps) => {
    const { children } = props
    const { firmwareVersion } = useContext(FirmwareVersionContext)

    const [isCacheModeOn, setIsCacheModeOn] = useState(false)
    const [payloadCacheMap, setPayloadCacheMap] = useState<Map<string, ArrayBuffer> | null>(null)
    const [manifestCache, setManifestCache] = useState<Map<FirmwareVersion, Map<number, IDirectory>> | null>(null)
    const [directoryMap, setDirectoryMap] = useState<Map<number, IDirectory> | null>(null)
    const [localStorageSize, setLocalStorageSize] = useState<number>(0)

    useEffect(() => {
        let mounted = true

        const fetchedPayloadCache = payloadCachingService.getCacheFromLocalStorage()
        const fetchedManifestCache = manifestService.getCacheFromLocalStorage()
        const fetchedLocalStorageSize = getLocalStorageSize()

        if (mounted) {
            setManifestCache(fetchedManifestCache)
            setPayloadCacheMap(fetchedPayloadCache)
            setLocalStorageSize(fetchedLocalStorageSize)
        }

        return () => {
            mounted = false
        }
    }, [])

    useEffect(() => {
        let mounted = true

        let dirMap: Map<number, IDirectory> | null = null
        if (manifestCache) {
            const cachedCopy = manifestCache.get(firmwareVersion)
            if (cachedCopy) {
                dirMap = cachedCopy
            }
        }

        if (!dirMap) {
            dirMap = manifestService.getDirectoryMapByFirmwareVersion(firmwareVersion)
        }

        if (mounted && dirMap) {
            setDirectoryMap(dirMap)
        }

        return () => {
            mounted = false
        }
    }, [firmwareVersion])

    const onLocalStorageSizeChanged = () => {
        setLocalStorageSize(getLocalStorageSize())
    }

    const onCacheManifests = () => {
        setManifestCache(manifestService.cacheAllManifests())
        onLocalStorageSizeChanged()
    }

    const onClearCachedManifests = () => {
        manifestService.clearAllCachedManifests()
        setManifestCache(null)
        onLocalStorageSizeChanged()
    }

    const hasCachedManifests = useMemo(() => {
        return manifestCache !== null && manifestCache.size > 0
    }, [manifestCache])

    const togglePayloadCacheInclusion = (payload: IPayload, buffer: ArrayBuffer) => {
        const identifier = payload.fullName

        const result = payloadCachingService.togglePayloadCacheInclusion(identifier, buffer)
        const copyCacheMap = payloadCacheMap
            ? { ...payloadCacheMap }
            : new Map<string, ArrayBuffer>()

        if (result) {
            const { key, value } = result
            copyCacheMap.set(key, value)
        } else {
            copyCacheMap.delete(identifier)
        }

        setPayloadCacheMap(copyCacheMap)
        onLocalStorageSizeChanged()
    }

    const clearPayloadCache = () => {
        payloadCachingService.clearPayloadCache()
        setPayloadCacheMap(null)
        onLocalStorageSizeChanged()
    }

    const clearLocalStorage = () => {
        localStorage.clear()
        setManifestCache(null)
        setPayloadCacheMap(null)
        onLocalStorageSizeChanged()
    }

    return (
        <CacheContext.Provider value={{
            isCacheModeOn: isCacheModeOn,
            localStorageSize: localStorageSize,
            payloadCacheMap: payloadCacheMap,
            setIsCacheModeOn: setIsCacheModeOn,
            togglePayloadCacheInclusion: togglePayloadCacheInclusion,
            clearPayloadCache: clearPayloadCache,
            clearLocalStorage: clearLocalStorage,
            directoryMap: directoryMap,
            hasCachedManifests: hasCachedManifests,
            onCacheManifests: onCacheManifests,
            onClearCachedManifests: onClearCachedManifests
        }}>
            {children}
        </CacheContext.Provider>)
}

export default CacheContextComponent