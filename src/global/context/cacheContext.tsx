import React, { createContext, useContext, useEffect, useMemo, useRef, useState } from 'react'
import { ServiceContext } from '.'
import { FirmwareVersion } from '../enums'
import { getLocalStorageSize } from '../helpers'
import { IDirectory, IKeyValuePair } from '../interfaces'

interface ICacheContextComponentProps {
    children: React.ReactNode
}

interface ICacheContext {
    firmwareVersion: FirmwareVersion,
    isCacheModeOn: boolean
    localStorageSize: number
    hasCachedManifests: boolean
    directoryMap: Map<number, IDirectory> | null
    payloadCacheMap: Set<string> | null
    setIsCacheModeOn: (on: boolean) => void
    togglePayloadCacheInclusion: (cacheIdentifier: string, buffer: Uint8Array) => void
    clearPayloadCache: () => void
    clearLocalStorage: () => void
    onCacheDirectoryPayloads: (directory: IDirectory) => void
    onCacheManifests: () => void
    onClearCachedManifests: () => void
    setFirmwareVersion: (firmwareVersion: FirmwareVersion) => void
}

export const CacheContext = createContext<ICacheContext>({
    firmwareVersion: FirmwareVersion.Undefined,
    isCacheModeOn: false,
    payloadCacheMap: null,
    localStorageSize: 0,
    hasCachedManifests: false,
    directoryMap: null,
    setIsCacheModeOn: () => Function.prototype,
    togglePayloadCacheInclusion: (_: string, __: Uint8Array) => Function.prototype,
    clearPayloadCache: () => Function.prototype,
    clearLocalStorage: () => Function.prototype,
    onCacheDirectoryPayloads: (_: IDirectory) => Function.prototype,
    onCacheManifests: () => Function.prototype,
    onClearCachedManifests: () => Function.prototype,
    setFirmwareVersion: (_: FirmwareVersion) => Function.prototype
})

const CacheContextComponent = (props: ICacheContextComponentProps) => {
    const { children } = props

    const {
        payloadCachingService,
        manifestService,
        binService
    } = useContext(ServiceContext)

    const [isCacheModeOn, setIsCacheModeOn] = useState(false)
    const [payloadCacheMap, setPayloadCacheMap] = useState<Set<string> | null>(null)
    const [manifestCache, setManifestCache] = useState<Map<FirmwareVersion, Map<number, IDirectory>> | null>(null)
    const [directoryMap, setDirectoryMap] = useState<Map<number, IDirectory> | null>(null)
    const [localStorageSize, setLocalStorageSize] = useState<number>(0)
    const [firmwareVersion, setFirmwareVersion] = useState<FirmwareVersion>(FirmwareVersion.Undefined)

    const firmwareVersionRef = useRef<FirmwareVersion>()

    useEffect(() => {
        let mounted = true

        const fetchedPayloadCache = payloadCachingService.getCacheKeys()
        const fetchedManifestCache = manifestService.retrieveCache()
        const fetchedLocalStorageSize = getLocalStorageSize()

        if (mounted) {
            setManifestCache(fetchedManifestCache)
            setPayloadCacheMap(fetchedPayloadCache)
            setLocalStorageSize(fetchedLocalStorageSize)
        }

        return () => {
            mounted = false
        }
    }, [payloadCachingService, manifestService])

    useEffect(() => {
        let mounted = true

        let dirMap: Map<number, IDirectory> | null = null

        if (firmwareVersion !== firmwareVersionRef.current) {
            if (manifestCache) {
                const cachedCopy = manifestCache.get(firmwareVersion)
                if (cachedCopy) {
                    dirMap = cachedCopy
                }
            }

            if (!dirMap) {
                dirMap = manifestService.getDirectoryMapByFirmwareVersion(firmwareVersion)
            }

            if (mounted && dirMap) {
                setDirectoryMap(dirMap)
            }

            firmwareVersionRef.current = firmwareVersion
        }

        return () => {
            mounted = false
        }
    }, [firmwareVersion, manifestCache, manifestService])

    const onLocalStorageSizeChanged = () => {
        setLocalStorageSize(getLocalStorageSize())
    }

    const onCacheManifests = () => {
        setManifestCache(manifestService.cacheAllManifests())
        onLocalStorageSizeChanged()
    }

    const onClearCachedManifests = () => {
        manifestService.clearAssociatedCache()
        setManifestCache(null)
        onLocalStorageSizeChanged()
    }

    const hasCachedManifests = useMemo(() => {
        return manifestCache !== null && manifestCache.size > 0
    }, [manifestCache])

    const togglePayloadCacheInclusion = (cacheIdentifier: string, buffer: Uint8Array) => {
        const result = payloadCachingService.togglePayloadCacheInclusion(cacheIdentifier, buffer)
        const copyCacheMap = payloadCacheMap
            ? new Set<string>(payloadCacheMap)
            : new Set<string>()

        if (result) {
            const { key } = result
            copyCacheMap.add(key)
        } else {
            copyCacheMap.delete(cacheIdentifier)
        }

        setPayloadCacheMap(copyCacheMap)
        onLocalStorageSizeChanged()
    }

    const clearPayloadCache = () => {
        payloadCachingService.clearAssociatedCache()
        setPayloadCacheMap(null)
        onLocalStorageSizeChanged()
    }

    const clearLocalStorage = () => {
        localStorage.clear()
        setManifestCache(null)
        setPayloadCacheMap(null)
        onLocalStorageSizeChanged()
    }

    const onCacheDirectoryPayloads = async (directory: IDirectory) => {
        const cachedPayloads = payloadCacheMap
            ? new Set<string>(payloadCacheMap)
            : new Set<string>()

        const nonCached = directory.payloads.filter(p => !cachedPayloads.has(p.path))

        let kvps: IKeyValuePair<string, Uint8Array>[] = []
        for (var { path: payloadPath } of nonCached) {
            const buffer = await binService.getBINFile(payloadPath)
            if (!buffer) {
                continue
            }

            cachedPayloads.add(payloadPath)
            kvps.push({
                key: payloadPath,
                value: buffer
            })
        }

        payloadCachingService.addToCache(kvps)
        setPayloadCacheMap(cachedPayloads)
        onLocalStorageSizeChanged()
    }

    return (
        <CacheContext.Provider value={{
            firmwareVersion: firmwareVersion,
            isCacheModeOn: isCacheModeOn,
            localStorageSize: localStorageSize,
            payloadCacheMap: payloadCacheMap,
            setIsCacheModeOn: setIsCacheModeOn,
            togglePayloadCacheInclusion: togglePayloadCacheInclusion,
            clearPayloadCache: clearPayloadCache,
            clearLocalStorage: clearLocalStorage,
            directoryMap: directoryMap,
            hasCachedManifests: hasCachedManifests,
            onCacheDirectoryPayloads: onCacheDirectoryPayloads,
            onCacheManifests: onCacheManifests,
            onClearCachedManifests: onClearCachedManifests,
            setFirmwareVersion: setFirmwareVersion
        }}>
            {children}
        </CacheContext.Provider>)
}

export default CacheContextComponent