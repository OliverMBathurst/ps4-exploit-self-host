import React, { createContext, useEffect, useMemo, useRef, useState } from 'react'
import { FirmwareVersion } from '../enums'
import { getLocalStorageSize } from '../helpers'
import { IDirectory, IPayload } from '../interfaces'
import { ManifestService, PayloadCachingService } from '../services'

interface ICacheContextComponentProps {
    children: React.ReactNode
}

interface ICacheContext {
    firmwareVersion: FirmwareVersion,
    isCacheModeOn: boolean
    localStorageSize: number
    hasCachedManifests: boolean
    directoryMap: Map<number, IDirectory> | null
    payloadCacheMap: Map<string, Uint8Array> | null
    setIsCacheModeOn: (on: boolean) => void
    togglePayloadCacheInclusion: (payload: IPayload, buffer: Uint8Array) => void
    clearPayloadCache: () => void
    clearLocalStorage: () => void
    onCacheManifests: () => void
    onClearCachedManifests: () => void
    setFirmwareVersion: (firmwareVersion: FirmwareVersion) => void
}

export const CacheContext = createContext<ICacheContext>({
    firmwareVersion: FirmwareVersion.Undefined,
    isCacheModeOn: false,
    payloadCacheMap: null,
    localStorageSize: 0,
    hasCachedManifests: false,
    directoryMap: null,
    setIsCacheModeOn: () => Function.prototype,
    togglePayloadCacheInclusion: (_: IPayload, __: Uint8Array) => Function.prototype,
    clearPayloadCache: () => Function.prototype,
    clearLocalStorage: () => Function.prototype,
    onCacheManifests: () => Function.prototype,
    onClearCachedManifests: () => Function.prototype,
    setFirmwareVersion: (_: FirmwareVersion) => Function.prototype
})

const payloadCachingService = new PayloadCachingService(), manifestService = new ManifestService()

const CacheContextComponent = (props: ICacheContextComponentProps) => {
    const { children } = props

    const [isCacheModeOn, setIsCacheModeOn] = useState(false)
    const [payloadCacheMap, setPayloadCacheMap] = useState<Map<string, Uint8Array> | null>(null)
    const [manifestCache, setManifestCache] = useState<Map<FirmwareVersion, Map<number, IDirectory>> | null>(null)
    const [directoryMap, setDirectoryMap] = useState<Map<number, IDirectory> | null>(null)
    const [localStorageSize, setLocalStorageSize] = useState<number>(0)
    const [firmwareVersion, setFirmwareVersion] = useState<FirmwareVersion>(FirmwareVersion.Undefined)

    const firmwareVersionRef = useRef<FirmwareVersion>()

    useEffect(() => {
        let mounted = true

        const fetchedPayloadCache = payloadCachingService.retrieveCache()
        const fetchedManifestCache = manifestService.retrieveCache()
        const fetchedLocalStorageSize = getLocalStorageSize()

        if (mounted) {
            setManifestCache(fetchedManifestCache)
            setPayloadCacheMap(fetchedPayloadCache)
            setLocalStorageSize(fetchedLocalStorageSize)
        }

        return () => {
            mounted = false
        }
    }, [])

    useEffect(() => {
        let mounted = true

        let dirMap: Map<number, IDirectory> | null = null

        if (firmwareVersion !== firmwareVersionRef.current) {
            if (manifestCache) {
                const cachedCopy = manifestCache.get(firmwareVersion)
                if (cachedCopy) {
                    dirMap = cachedCopy
                }
            }

            if (!dirMap) {
                dirMap = manifestService.getDirectoryMapByFirmwareVersion(firmwareVersion)
            }

            if (mounted && dirMap) {
                setDirectoryMap(dirMap)
            }

            firmwareVersionRef.current = firmwareVersion
        }

        return () => {
            mounted = false
        }
    }, [firmwareVersion, manifestCache])

    const onLocalStorageSizeChanged = () => {
        setLocalStorageSize(getLocalStorageSize())
    }

    const onCacheManifests = () => {
        setManifestCache(manifestService.cacheAllManifests())
        onLocalStorageSizeChanged()
    }

    const onClearCachedManifests = () => {
        manifestService.clearAssociatedCache()
        setManifestCache(null)
        onLocalStorageSizeChanged()
    }

    const hasCachedManifests = useMemo(() => {
        return manifestCache !== null && manifestCache.size > 0
    }, [manifestCache])

    const togglePayloadCacheInclusion = (payload: IPayload, buffer: Uint8Array) => {
        const identifier = payload.fullName

        const result = payloadCachingService.togglePayloadCacheInclusion(identifier, buffer)
        const copyCacheMap = payloadCacheMap
            ? new Map<string, Uint8Array>(payloadCacheMap)
            : new Map<string, Uint8Array>()

        if (result) {
            const { key, value } = result
            copyCacheMap.set(key, value)
        } else {
            copyCacheMap.delete(identifier)
        }

        setPayloadCacheMap(copyCacheMap)
        onLocalStorageSizeChanged()
    }

    const clearPayloadCache = () => {
        payloadCachingService.clearAssociatedCache()
        setPayloadCacheMap(null)
        onLocalStorageSizeChanged()
    }

    const clearLocalStorage = () => {
        localStorage.clear()
        setManifestCache(null)
        setPayloadCacheMap(null)
        onLocalStorageSizeChanged()
    }

    return (
        <CacheContext.Provider value={{
            firmwareVersion: firmwareVersion,
            isCacheModeOn: isCacheModeOn,
            localStorageSize: localStorageSize,
            payloadCacheMap: payloadCacheMap,
            setIsCacheModeOn: setIsCacheModeOn,
            togglePayloadCacheInclusion: togglePayloadCacheInclusion,
            clearPayloadCache: clearPayloadCache,
            clearLocalStorage: clearLocalStorage,
            directoryMap: directoryMap,
            hasCachedManifests: hasCachedManifests,
            onCacheManifests: onCacheManifests,
            onClearCachedManifests: onClearCachedManifests,
            setFirmwareVersion: setFirmwareVersion
        }}>
            {children}
        </CacheContext.Provider>)
}

export default CacheContextComponent