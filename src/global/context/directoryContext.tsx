import React, { createContext, useContext, useEffect, useMemo, useState } from 'react';
import { BrowserContext, CacheContext, ModalContext, ServiceContext } from '.';
import { FirmwareVersion, ModalType } from '../enums';
import { IDirectory, IPayload, IPayloadService } from '../interfaces';
import { NinePointZeroZeroPayloadService } from '../services/versioned/9.00';

interface IDirectoryContextComponentProps {
    children: React.ReactNode
}

interface IDirectoryContext {
    currentDirectory: IDirectory | null
    hasAboveLevel: boolean,
    onPayloadSelected: (payload: IPayload) => void
    onDirectorySwitch: (directoryId: number | null) => void
    onUpOneLevel: () => void
}

export const DirectoryContext = createContext<IDirectoryContext>({
    currentDirectory: null,
    hasAboveLevel: false,
    onPayloadSelected: (_: IPayload) => Function.prototype,
    onDirectorySwitch: (_: number | null) => Function.prototype,
    onUpOneLevel: () => Function.prototype
})

const DirectoryContextComponent = (props: IDirectoryContextComponentProps) => {
    const { children } = props

    const { binService, payloadCachingService } = useContext(ServiceContext)
    const { isBrowserExploitable, ps4IPAddress } = useContext(BrowserContext)
    const { addModal } = useContext(ModalContext)
    const {
        firmwareVersion,
        isCacheModeOn,
        payloadCacheKeysSet,
        togglePayloadCacheInclusion,
        directoryMap,
        setFirmwareVersion
    } = useContext(CacheContext)

    const [currentDirectory, setCurrentDirectory] = useState<IDirectory | null>(null)

    useEffect(() => {
        let mounted = true

        if (directoryMap) {
            const manifestRoot = directoryMap.get(0)
            if (manifestRoot && mounted) {
                setCurrentDirectory(manifestRoot)
            } else {
                throw new Error("Failed to set manifest root")
            }
        }

        return () => {
            mounted = false
        }
    }, [directoryMap])

    const payloadService: IPayloadService | null = useMemo(() => {
        if (firmwareVersion === FirmwareVersion.NinePointZeroZero) {
            return new NinePointZeroZeroPayloadService()
        }

        return null
    }, [firmwareVersion])

    const onPayloadSelected = async (payload: IPayload): Promise<void> => {
        if (!currentDirectory) {
            addModal({
                title: "Directory Not Specified",
                message: "Current directory not specified."
            })
            return
        }

        if (!payloadService) {
            addModal({
                title: "Payload Service Error",
                message: "Could not find payload service."
            })
            return
        }

        let binFile: Uint8Array | null = null

        if (!isCacheModeOn && payloadCacheKeysSet) {
            const payloadCacheResult = await payloadCachingService.performCacheLookup(payload.path)
            if (payloadCacheResult.data) {
                binFile = payloadCacheResult.data
                addModal({
                    title: "Cache Notification",
                    message: `Fetched ${payload.name} from cache.`,
                    type: ModalType.FadeOut,
                    hasDismissButton: false
                })
            }
        }

        if (binFile) {
            onBinFileLoaded(payload, binFile)
        } else {
            binService.getBINFileWithCallback(payload.path, (buffer) => onBinFileLoaded(payload, buffer), addModal)
        }
    }

    const onBinFileLoaded = (payload: IPayload, binFile: Uint8Array): void => {
        if (!payloadService) {
            addModal({
                title: "Payload Service Error",
                message: "Could not find payload service."
            })
            return
        }

        if (isCacheModeOn) {
            togglePayloadCacheInclusion(payload.path, binFile)
        } else {
            let binLoaderStatusEndpoint: string | undefined = undefined
            let binLoaderEndpoint: string | undefined = undefined

            if (!isBrowserExploitable) {
                if (!ps4IPAddress) {
                    addModal({
                        title: "IP Address Notification",
                        message: "The provided IP Address is invalid.",
                        type: ModalType.FadeOut,
                        hasDismissButton: false
                    })
                    return
                } else {
                    binLoaderStatusEndpoint = `http://${ps4IPAddress}:${payloadService.portNumber}/status`
                    binLoaderEndpoint = `http://${ps4IPAddress}:${payloadService.portNumber}`
                }
            }

            payloadService.handlePayload(
                payload,
                binFile,
                binLoaderStatusEndpoint,
                binLoaderEndpoint,
                binLoaderEndpoint ? addModal : undefined)
        }
    }

    const onDirectorySwitch = (directoryId: number | null): void => {
        if (!directoryMap) {
            addModal({
                title: "Directory Map Error",
                message: "Directory map not specified"
            })
            return
        }

        if (directoryId === null) {
            addModal({
                title: "Directory Error",
                message: "Invalid directory specified"
            })
            return
        }

        const dir = directoryMap.get(directoryId)
        if (dir) {
            setCurrentDirectory(dir)

            if (dir.firmwareVersionBarrier !== undefined) {
                setFirmwareVersion(dir.firmwareVersionBarrier)
            }
        } else {
            addModal({
                title: "Directory Error",
                message: `Could not get directory ${directoryId}`
            })
        }
    }

    const onUpOneLevel = (): void => {
        if (!currentDirectory) {
            addModal({
                title: "Directory Error",
                message: "Current directory is undefined"
            })
            return
        }

        if (!directoryMap) {
            addModal({
                title: "Directory Error",
                message: "Directory map is undefined"
            })
            return
        }

        if (currentDirectory.parent !== null) {
            const parent = directoryMap.get(currentDirectory.parent)
            if (!parent) {
                addModal({
                    title: "Directory Error",
                    message: "Parent directory cannot be found"
                })
                return
            }

            setCurrentDirectory(parent)
        } else if (firmwareVersion !== FirmwareVersion.Undefined) {
            setFirmwareVersion(FirmwareVersion.Undefined)
        } else {
            addModal({
                title: "Directory Error",
                message: "Cannot navigate upwards"
            })
        }
    }

    const hasAboveLevel = useMemo(() => {
        return firmwareVersion !== FirmwareVersion.Undefined
            || (currentDirectory !== null && currentDirectory.parent !== null)
    }, [firmwareVersion, currentDirectory])

    return (
        <DirectoryContext.Provider value={{
            currentDirectory: currentDirectory,
            hasAboveLevel: hasAboveLevel,
            onPayloadSelected: onPayloadSelected,
            onDirectorySwitch: onDirectorySwitch,
            onUpOneLevel: onUpOneLevel
        }}>
            {children}
        </DirectoryContext.Provider>)
}

export default DirectoryContextComponent