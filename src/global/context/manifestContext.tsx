import React, { createContext, useContext, useEffect, useMemo, useState } from 'react'
import { FirmwareVersion } from '../enums'
import { IDirectory } from '../interfaces'
import { ManifestService } from '../services'
import { FirmwareVersionContext } from './firmwareVersionContext'

interface IManifestContextComponentProps {
    children: React.ReactNode
}

interface IManifestContext {
    directoryMap: Map<number, IDirectory> | null
    hasCachedManifests: boolean
    onCacheManifests: () => void
    onClearCachedManifests: () => void
}

export const ManifestContext = createContext<IManifestContext>({
    hasCachedManifests: false,
    directoryMap: null,
    onCacheManifests: () => Function.prototype,
    onClearCachedManifests: () => Function.prototype
})

const manifestService = new ManifestService()

const ManifestContextComponent = (props: IManifestContextComponentProps) => {
    const { children } = props

    const { firmwareVersion } = useContext(FirmwareVersionContext)

    const [cache, setCache] = useState<Map<FirmwareVersion, Map<number, IDirectory>> | null>(null)
    const [directoryMap, setDirectoryMap] = useState<Map<number, IDirectory> | null>(null)

    useEffect(() => {
        let mounted = true

        const fetchedCache = manifestService.getCacheFromLocalStorage()
        if (mounted && fetchedCache && fetchedCache.size > 0) {
            setCache(fetchedCache)
        }

        return () => {
            mounted = false
        }
    }, [])

    useEffect(() => {
        let mounted = true

        let dirMap: Map<number, IDirectory> | null = null
        if (cache) {
            const cachedCopy = cache.get(firmwareVersion)
            if (cachedCopy) {
                dirMap = cachedCopy
            }
        }

        if (!dirMap) {
            dirMap = manifestService.getDirectoryMapByFirmwareVersion(firmwareVersion)
        }

        if (mounted && dirMap) {
            setDirectoryMap(dirMap)
        }

        return () => {
            mounted = false
        }
    }, [firmwareVersion])

    const onCacheManifests = () => {
        setCache(manifestService.cacheAllManifests())
    }

    const onClearCachedManifests = () => {
        manifestService.clearAllCachedManifests()
        setCache(null)
    }

    const hasCachedManifests = useMemo(() => {
        return cache !== null && cache.size > 0
    }, [cache])

    return (
        <ManifestContext.Provider value={{
            directoryMap: directoryMap,
            hasCachedManifests: hasCachedManifests,
            onCacheManifests: onCacheManifests,
            onClearCachedManifests: onClearCachedManifests
        }}>
            {children}
        </ManifestContext.Provider>)
}

export default ManifestContextComponent