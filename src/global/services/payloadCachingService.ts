import { toMap } from "../helpers"
import { ICacheService, IKeyValuePair } from "../interfaces"
import { AbstractCacheService } from "./abstract"

interface IPayloadCachingService {
    togglePayloadCacheInclusion: (identifier: string, buffer: Uint8Array) => IKeyValuePair<string, Uint8Array> | null
}

const storageKey: string = "payloadCache"

class PayloadCachingService
    extends AbstractCacheService
    implements IPayloadCachingService, ICacheService<Map<string, Uint8Array> | null>
{
    private decoder: TextDecoder = new TextDecoder("utf-8")
    private encoder: TextEncoder = new TextEncoder()

    constructor() {
        super(storageKey)
    }

    togglePayloadCacheInclusion = (identifier: string, buffer: Uint8Array) => {
        const deserializedCache = this.retrieveCache() || new Map<string, Uint8Array>()

        const payloadMap: Map<string, string> = toMap(
            deserializedCache,
            p => p[0],
            p => this.decoder.decode(new Int32Array(p[1])))

        const existsInMap = payloadMap.has(identifier)
        if (existsInMap) {
            payloadMap.delete(identifier)
        } else {
            payloadMap.set(identifier, this.decoder.decode(new Int32Array(buffer)))
        }

        localStorage.setItem(storageKey, JSON.stringify(Array.from(payloadMap.entries())))

        return existsInMap
            ? null
            : {
                key: identifier,
                value: buffer
            }
    }

    retrieveCache = (): Map<string, Uint8Array> | null => {
        const cache = localStorage.getItem(storageKey)

        if (cache) {
            const payloadsArr: [string, string] = JSON.parse(cache)
            return toMap(
                payloadsArr,
                p => p[0],
                p => this.encoder.encode(p[1]))
        }

        return null
    }
}

export default PayloadCachingService