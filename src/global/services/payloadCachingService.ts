import { toMap } from "../helpers"
import { ICacheService, IKeyValuePair } from "../interfaces"
import { AbstractCacheService } from "./abstract"

interface IPayloadCachingService {
    getCacheValueByKey: (identifier: string) => Uint8Array | null
    addToCache: (keyValuePairs: IKeyValuePair<string, Uint8Array>[]) => void
    getCacheKeys: () => Set<string>
    togglePayloadCacheInclusion: (identifier: string, buffer: Uint8Array) => IKeyValuePair<string, Uint8Array> | null
}

class PayloadCachingService
    extends AbstractCacheService
    implements IPayloadCachingService, ICacheService<Map<string, Uint8Array> | null>
{
    private decoder: TextDecoder = new TextDecoder("utf-8")
    private encoder: TextEncoder = new TextEncoder()

    constructor() {
        super("payloadCache")
    }

    getCacheValueByKey = (identifier: string) => {
        const cache = this.getAssociatedCache()
        if (cache) {
            const payloadsArr: [string, string] = JSON.parse(cache)
            const idx = payloadsArr.findIndex(x => x[0] === identifier)
            if (idx !== -1) {
                return this.encoder.encode(payloadsArr[idx])
            }
        }

        return null
    }

    getCacheKeys = () => {
        const set = new Set<string>()
        const cache = this.getAssociatedCache()
        if (cache) {
            const payloadsArr: [string, string] = JSON.parse(cache)
            for (var [key, _] of payloadsArr) {
                set.add(key)
            }
        }

        return set
    }

    addToCache = (keyValuePairs: IKeyValuePair<string, Uint8Array>[]) => {
        const cache = this.retrieveCache() || new Map<string, Uint8Array>()

        for (var { key, value } of keyValuePairs) {
            if (!cache.has(key)) {
                cache.set(key, value)
            }
        }

        const toSerialize: Map<string, string> = toMap(
            cache,
            p => p[0],
            p => this.decoder.decode(p[1]))

        localStorage.setItem(this.storageKey, JSON.stringify(Array.from(toSerialize.entries())))
    }

    togglePayloadCacheInclusion = (identifier: string, buffer: Uint8Array) => {
        const deserializedCache = this.retrieveCache() || new Map<string, Uint8Array>()

        const payloadMap: Map<string, string> = toMap(
            deserializedCache,
            p => p[0],
            p => this.decoder.decode(new Int32Array(p[1])))

        const existsInMap = payloadMap.has(identifier)
        if (existsInMap) {
            payloadMap.delete(identifier)
        } else {
            payloadMap.set(identifier, this.decoder.decode(new Int32Array(buffer)))
        }

        localStorage.setItem(this.storageKey, JSON.stringify(Array.from(payloadMap.entries())))

        return existsInMap
            ? null
            : {
                key: identifier,
                value: buffer
            }
    }

    retrieveCache = () => {
        const cache = this.getAssociatedCache()

        if (cache) {
            const payloadsArr: [string, string] = JSON.parse(cache)
            return toMap(
                payloadsArr,
                p => p[0],
                p => this.encoder.encode(p[1]))
        }

        return null
    }
}

export default PayloadCachingService