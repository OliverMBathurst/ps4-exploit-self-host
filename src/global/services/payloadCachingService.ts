import { toMap } from "../helpers"
import { IKeyValuePair } from "../interfaces"

interface IPayloadCachingService {
    clearPayloadCache: () => void
    togglePayloadCacheInclusion: (identifier: string, buffer: ArrayBuffer) => IKeyValuePair<string, ArrayBuffer> | null
    getCacheFromLocalStorage: () => Map<string, ArrayBuffer> | null
}

const storageKey: string = "payloadCache"

class PayloadCachingService implements IPayloadCachingService {

    getCacheFromLocalStorage = () => {
        const arrTuples = localStorage.getItem(storageKey)
        if (!arrTuples) {
            return null
        }

        const payloadsArr: [string, string] = JSON.parse(arrTuples)
        const payloads: Map<string, string> = toMap(payloadsArr, p => p[0], p => p[1])

        const correctedPayloads = new Map<string, ArrayBuffer>()

        for (var entry of payloads) {
            const arrBuffEncoded = new TextEncoder().encode(entry[1])
            correctedPayloads.set(entry[0], arrBuffEncoded.buffer)
        }

        return correctedPayloads
    }

    clearPayloadCache = () => {
        localStorage.removeItem(storageKey)
    }

    togglePayloadCacheInclusion = (identifier: string, buffer: ArrayBuffer) => {
        const storedMap = localStorage.getItem(storageKey)

        let payloadMap: Map<string, string> | null = null
        if (storedMap) {
            const payloadArr: [string, string] = JSON.parse(storedMap)
            payloadMap = toMap(payloadArr, p => p[0], p => p[1])
        } else {
            payloadMap = new Map<string, string>()
        }

        let hasDeleted = false
        if (payloadMap.get(identifier)) {
            payloadMap.delete(identifier)
            hasDeleted = true
        } else {
            const str = new TextDecoder("utf-8").decode(new Int32Array(buffer));
            payloadMap.set(identifier, str)
        }

        localStorage.setItem(storageKey, JSON.stringify(Array.from(payloadMap.entries())))

        return hasDeleted
            ? null
            : {
                key: identifier,
                value: buffer
            }
    }
}

export default PayloadCachingService