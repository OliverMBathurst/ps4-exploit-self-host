import { DB_TRANSACTION_MODE_READ_WRITE } from "../../constants"
import { CacheResultType } from "../../enums"
import { ICacheResult, ICacheResultWithData } from "../../interfaces"
import { Nullable } from "../../types"
import DatabaseService from "../databaseService"

interface IAbstractCacheService<TEntity> {
    clearAssociatedObjectStore: () => Promise<ICacheResult>
    addToObjectStore: (key: IDBValidKey, value: TEntity) => Promise<ICacheResult>
    deleteFromCache: (query: IDBValidKey) => Promise<ICacheResult>
    performCacheLookup: (query: IDBValidKey) => Promise<ICacheResultWithData<TEntity | null>>
    getCacheKeys: () => Promise<ICacheResultWithData<IDBValidKey[] | null>>
    hasCacheKeys: () => Promise<ICacheResultWithData<boolean>>
}

const databaseService = new DatabaseService()

abstract class AbstractCacheService<TEntity> implements IAbstractCacheService<TEntity> {
    private storageKey: string

    private cacheResultTemplates = {
        objectStoreDoesNotExist: {
            success: false,
            message: "Object store does not exist.",
            reason: CacheResultType.ObjectStoreDoesNotExist
        }
    }

    constructor(storageKey: string) {
        this.storageKey = storageKey
    }

    clearAssociatedObjectStore = (): Promise<ICacheResult> => {
        return new Promise<ICacheResult>(resolve => {
            this.getObjectStore(DB_TRANSACTION_MODE_READ_WRITE).then(res => {
                const store = res.data
                if (store) {
                    store.clear()
                }

                resolve({
                    success: true,
                    message: `Object store ${store ? "cleared" : "does not exist"}.`,
                    reason: store
                        ? CacheResultType.ObjectStoreCleared
                        : CacheResultType.ObjectStoreDoesNotExist
                })
            })
        })
    }

    addToObjectStore = (key: IDBValidKey, value: TEntity): Promise<ICacheResult> => {
        return new Promise<ICacheResult>(resolve => {
            this.getObjectStore(DB_TRANSACTION_MODE_READ_WRITE).then(res => {
                let store = res.data

                if (!store) {
                    resolve({
                        success: false,
                        message: "Object store does not exist.",
                        reason: CacheResultType.ObjectStoreDoesNotExist
                    })
                } else {
                    store.add(value, key)
                    resolve({
                        success: true,
                        message: "Entry added to object store.",
                        reason: CacheResultType.ObjectStoreEntryAdded
                    })
                }
            })
        })
    }

    deleteFromCache = (query: IDBValidKey): Promise<ICacheResult> => {
        return new Promise<ICacheResult>(resolve => {
            this.getObjectStore().then(res => {
                const store = res.data
                if (!store) {
                    resolve({
                        ...this.cacheResultTemplates.objectStoreDoesNotExist,
                        success: true
                    })
                } else {
                    const request = store.delete(query)

                    request.onsuccess = () => {
                        resolve(request.result !== undefined
                            ? {
                                success: true,
                                message: `Cached value for: ${query} has been deleted.`,
                                reason: CacheResultType.ObjectStoreEntryDeleted
                            }
                            : this.getGenericErrorByRequest(request)
                        )
                    }

                    request.onerror = () => resolve(this.getGenericErrorByRequest(request))
                }
            })
        })
    }

    performCacheLookup = (query: IDBValidKey): Promise<ICacheResultWithData<Nullable<TEntity>>> => {
        return new Promise<ICacheResultWithData<Nullable<TEntity>>>(resolve => {
            this.getObjectStore()
                .then(res => {
                    const store = res.data
                    if (!store) {
                        resolve({
                            ...this.cacheResultTemplates.objectStoreDoesNotExist,
                            data: null
                        })
                    } else {
                        let request = store.get(query)

                        request.onsuccess = () => {
                            const success = request.result !== undefined

                            resolve({
                                success: success,
                                message: `${success ? "S" : "Uns"}uccessfully obtained cached value for: ${query}.`,
                                data: success
                                    ? request.result
                                    : null,
                                reason: success
                                    ? CacheResultType.ObjectStoreEntryRetrieved
                                    : CacheResultType.ObjectStoreEntryNotRetrieved
                            })
                        }

                        request.onerror = () => resolve(this.getGenericErrorByRequestWithData(request))
                    }
                }).catch(e => {
                    resolve({
                        success: false,
                        message: e.message,
                        reason: CacheResultType.Undefined,
                        data: null
                    })
                })
        })
    }

    getCacheKeys = (): Promise<ICacheResultWithData<Nullable<IDBValidKey[]>>> => {
        return new Promise<ICacheResultWithData<Nullable<IDBValidKey[]>>>(resolve => {
            this.getObjectStore().then(res => {
                const store = res.data
                if (!res.success || !store) {
                    resolve({
                        ...this.cacheResultTemplates.objectStoreDoesNotExist,
                        data: null
                    })
                } else {
                    let request = store.getAllKeys()

                    request.onsuccess = () => {
                        if (request.result !== undefined) {
                            resolve({
                                success: true,
                                message: "Successfully retrieved object store keys.",
                                data: request.result,
                                reason: CacheResultType.ObjectStoreKeysRetrieved
                            })
                        } else {
                            resolve({
                                ...this.getGenericErrorByRequest(request),
                                data: null
                            })
                        }
                    }

                    request.onerror = () => resolve(this.getGenericErrorByRequestWithData(request))
                }
            })
        })
    }

    hasCacheKeys = (): Promise<ICacheResultWithData<boolean>> => {
        return new Promise<ICacheResultWithData<boolean>>(resolve => {
            this.getObjectStore().then(res => {
                const store = res.data
                if (!res.success || !store) {
                    resolve({
                        ...res,
                        data: false
                    })
                } else {
                    const request = store.getAllKeys()

                    request.onerror = () => resolve({
                        success: true,
                        message: "Failed to retrieve cache keys.",
                        data: false,
                        reason: CacheResultType.ObjectStoreKeysNotRetrieved
                    })

                    request.onsuccess = () => {
                        resolve({
                            success: true,
                            message: "Successfully retrieved cache keys.",
                            data: request.result.length > 0,
                            reason: CacheResultType.ObjectStoreKeysRetrieved
                        })
                    }
                }
            })
        })
    }

    private getObjectStore = (dbTransactionMode: IDBTransactionMode = "readonly"): Promise<ICacheResultWithData<Nullable<IDBObjectStore>>> => {
        return new Promise<ICacheResultWithData<Nullable<IDBObjectStore>>>(resolve => {
            const onSuccessCallback = (
                _request: IDBOpenDBRequest,
                result: IDBDatabase
            ) => {
                const exists = result.objectStoreNames.contains(this.storageKey)

                let cacheResult: ICacheResultWithData<Nullable<IDBObjectStore>> = !exists
                    ? {
                        ...this.cacheResultTemplates.objectStoreDoesNotExist,
                        data: null
                    } : {
                        success: true,
                        message: "Object store does exist.",
                        data: result.transaction(this.storageKey, dbTransactionMode).objectStore(this.storageKey),
                        reason: CacheResultType.ObjectStoreDoesExist
                    }

                resolve(cacheResult)
            }

            const onUpgradeNeededCallback = (
                _request: IDBOpenDBRequest,
                event: IDBVersionChangeEvent,
                _result: IDBDatabase
            ) => {
                resolve({
                    success: false,
                    message: event.oldVersion < 1
                        ? "Object store does not exist."
                        : "Database is outdated, please reload the page.",
                    data: null,
                    reason: CacheResultType.DatabaseNeedsUpgrade
                })
            }

            const onDatabaseErrorCallback = (request: IDBOpenDBRequest, _event: Event, _result: IDBDatabase) => {
                resolve(this.getGenericErrorByRequestWithData(request))
            }

            databaseService.getDatabase(onSuccessCallback, onUpgradeNeededCallback, onDatabaseErrorCallback)
        })
    }

    private getGenericErrorByRequestWithData = <T>(request: IDBRequest): ICacheResultWithData<Nullable<T>> => {
        return {
            ...this.getGenericErrorByRequest(request),
            data: null
        }
    }

    private getGenericErrorByRequest = (request: IDBRequest): ICacheResult => {
        return {
            success: false,
            message: request.error
                ? `Message: ${request.error.message}, code: ${request.error.code}.`
                : "Unspecified error.",
            reason: CacheResultType.Undefined
        }
    }
}

export default AbstractCacheService