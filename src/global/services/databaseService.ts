import { DATABASE_NAME, OBJECT_STORE_NAMES } from "../constants"
import { CacheResultType } from "../enums"
import { ICacheResult, ICacheResultWithData } from "../interfaces"
import { Nullable } from "../types"

interface IDatabaseService {
    getDatabase: (
        onSuccessCallback: (request: IDBOpenDBRequest, result: IDBDatabase) => void,
        onDatabaseUpgradeNeeded?: (request: IDBOpenDBRequest, event: IDBVersionChangeEvent, result: IDBDatabase) => void,
        onDatabaseErrorCallback?: (request: IDBOpenDBRequest, event: Event, result: IDBDatabase) => void
    ) => void
    deleteDatabase: (
        onSuccessCallback: (request: IDBOpenDBRequest, result: IDBDatabase) => void,
        onDatabaseUpgradeNeeded?: (request: IDBOpenDBRequest, event: IDBVersionChangeEvent, result: IDBDatabase) => void,
        onDatabaseErrorCallback?: (request: IDBOpenDBRequest, event: Event, result: IDBDatabase) => void
    ) => void
    getObjectStoreKeyCount: () => Promise<ICacheResultWithData<Nullable<number>>>
    clearObjectStores: () => Promise<ICacheResult>
}

class DatabaseService implements IDatabaseService {
    getDatabase = (
        onSuccessCallback: (request: IDBOpenDBRequest, result: IDBDatabase) => void,
        onDatabaseUpgradeNeededCallback?: (request: IDBOpenDBRequest, event: IDBVersionChangeEvent, result: IDBDatabase) => void,
        onDatabaseErrorCallback?: (request: IDBOpenDBRequest, event: Event, result: IDBDatabase) => void
    ): void => {
        let request = window.indexedDB.open(DATABASE_NAME, 1)

        request.onerror = (event: Event) => {
            if (onDatabaseErrorCallback) {
                onDatabaseErrorCallback(request, event, request.result)
            }
        }

        request.onupgradeneeded = (event: IDBVersionChangeEvent) => {
            const store = request.result

            for (var objectStoreName of OBJECT_STORE_NAMES) {
                if (!store.objectStoreNames.contains(objectStoreName)) {
                    store.createObjectStore(objectStoreName)
                }
            }

            if (onDatabaseUpgradeNeededCallback) {
                onDatabaseUpgradeNeededCallback(request, event, request.result)
            }
        }

        request.onsuccess = (_ev: Event) => {
            onSuccessCallback(request, request.result)
        }
    }

    deleteDatabase = (
        onSuccessCallback: (request: IDBOpenDBRequest, result: IDBDatabase) => void,
        onDatabaseUpgradeNeededCallback?: (request: IDBOpenDBRequest, event: IDBVersionChangeEvent, result: IDBDatabase) => void,
        onDatabaseErrorCallback?: (request: IDBOpenDBRequest, event: Event, result: IDBDatabase) => void
    ): void => {
        let request = window.indexedDB.deleteDatabase(DATABASE_NAME)

        request.onerror = (event: Event) => {
            if (onDatabaseErrorCallback) {
                onDatabaseErrorCallback(request, event, request.result)
            }
        }

        request.onupgradeneeded = (event: IDBVersionChangeEvent) => {
            if (onDatabaseUpgradeNeededCallback) {
                onDatabaseUpgradeNeededCallback(request, event, request.result)
            }
        }

        request.onsuccess = () => onSuccessCallback(request, request.result)
    }

    clearObjectStores = (): Promise<ICacheResult> => {
        return new Promise<ICacheResult>(resolve => {
            const resolveWithResult = (result: IDBDatabase, success: boolean = true) => {
                if (success) {
                    for (var objectStoreName of OBJECT_STORE_NAMES) {
                        result.transaction(objectStoreName, "readwrite").objectStore(objectStoreName).clear()
                    }
                }

                resolve({
                    success: success,
                    message: `${success ? "S" : "Uns"}uccessfully cleared object stores.`,
                    reason: success ? CacheResultType.ObjectStoreCleared : CacheResultType.ObjectStoreNotCleared
                })
            }

            const onSuccessCallback = (_request: IDBOpenDBRequest, result: IDBDatabase) => {
                resolveWithResult(result)
            }

            const onDatabaseErrorCallback = (_request: IDBOpenDBRequest, _event: Event, result: IDBDatabase) => {
                resolveWithResult(result, false)
            }

            this.getDatabase(
                onSuccessCallback,
                undefined,
                onDatabaseErrorCallback
            )
        })
    }

    getObjectStoreKeyCount = (): Promise<ICacheResultWithData<number>> => {
        return new Promise<ICacheResultWithData<number>>(resolve => {
            const resolveWithResult = (result: IDBDatabase, success: boolean = true) => {
                if (!success) {
                    resolve({
                        success: false,
                        message: "Unsuccessfully retrieved object stores count.",
                        reason: CacheResultType.ObjectStoresKeyCountNotRetrieved,
                        data: 0
                    })
                } else {
                    let storeNames = []
                    for (var objectStoreName of result.objectStoreNames) {
                        storeNames.push(objectStoreName)
                    }

                    const promises = storeNames.map(name => {
                        return new Promise<number>(innerResolve => {
                            const countRequest = result.transaction(name, "readonly").objectStore(name).count()
                            countRequest.onsuccess = () => innerResolve(countRequest.result)
                        })
                    })

                    Promise.all(promises).then(results => {
                        resolve({
                            success: true,
                            message: "Successfully retrieved object stores count.",
                            reason: CacheResultType.ObjectStoresKeyCountRetrieved,
                            data: results.reduce((a, b) => a + b, 0)
                        })
                    })
                }
            }

            const onSuccessCallback = (_request: IDBOpenDBRequest, result: IDBDatabase) => {
                resolveWithResult(result)
            }

            const onDatabaseErrorCallback = (_request: IDBOpenDBRequest, _event: Event, result: IDBDatabase) => {
                resolveWithResult(result, false)
            }

            this.getDatabase(
                onSuccessCallback,
                undefined,
                onDatabaseErrorCallback
            )
        })
    }
}

export default DatabaseService